用来记载自己做项目时的细节，防止遗忘，基本上本文档会最终整合到其他文档中，读者没必要看，只是自己逐步实现项目时的记录，当然如果你感兴趣一步步怎么搭建出来的可以看看，作为一个可选项吧。
# 日志系统
> made in 2021.11.27

* GDB多线程调试真麻烦，虽然很清晰，但是我始终觉得效率不高，还是直接printf实在，不过gdb用来学习代码逻辑倒是非常不错。
* 有一说一，智能指针真的很好用，能帮你发现许多写代码时的小问题，除了什么RAII、copy on write、对象生命期管理等一堆手法技巧，还能帮你检查代码逻辑呢，具体原因可以看我上面的第一条。

# 初步Reactor
**Channel,EventLoop,Poller**
这三个构成了reactor的核心框架
channel为具体事件分发器，每一个文件描述符都对应一个channel，每一个Poller都拥有所有的已经注册的Channel，并通过map管理
EventLoop 拥有唯一的一个Poller对象，借助它实现I/O复用。每次EventLoop调用poll，Poller将激活的Channels列表提供给EventLoop,
相当于Poller是其的一个工具类。
EventLoop拥有所有channel，并且通过成员函数可以自己选择是否注册channel到自己的poller。
这种设计分层方便替换I/O复用工具，比如把Poller换成Epoll。

细节：
1. channel定义时指定自己的eventloop，channel.enableReading()时注册Poller
2. 用了大量断言，确保每个channel 和 poller的使用时是在所属于的rector线程(eventloop线程)。增加程序健壮性。

# 定时器TimerQueue

**Timer类**:具体的定时器事件，具有几大属性，即定时时间、重复性与否、周期间隔时间，以及具体绑定的回调函数

```c++
Timestamp expiration_;
const bool repeat_;
const double interval_;
const TimerCallback callback_;
```
**TimerQueue类**:

* 定时器的管理着，处理定时器集合，定时到期处理，设置下一个定时时间等，
拥有实际的timefd文件描述符，在初始化时便将文件描述符插入了Poller可读，一但设置定时Timer则开始运转。

* 为具体读timefd的对象（timefd每次触发一定要读出来，因为采用的水平触发），读完timefd后计算当前时间，计算
此时到期时间，并使用管理的timefd的回调函数逐个处理对应的注册回调，然后删除过期时间（会同时计算repeat Timer重新插入），重新取最新的定时Timer为第一。
* 采用红黑树set管理定时器，因为红黑树支持快速插入，自动排序等功能，不采用map是因为已经使用了pair<,>。
  
* 每一个I/O线程拥有唯一的一个TimerQueue，所以是针对每个reactor的定时。

* 用户不能直接使用它的成员函数插入，对用户不可见。用户使用外部EventLoop类的接口进行插入定时器。但这样会存在线程安全性问题，因为有可能多个线程设计此I/O线程的定时，因此使用EventLoop::runInLoop()函数实现事件转发，让该事件转发给I/O线程来做

**EventLoop类**： 更新方法

*一系列解决reacotrs通信线程安全的方法*

EventLoop用容器vector提供回调队列，各回调函数若因为线程安全问题无法运行时，会将函数回调插入此队列，
I/O线程会在执行完所有channel回调后，再执行完队列回调。**巧妙的解决了线程安全问题，将事件转发给实际解决回调函数的地方。

注意：每次插入了回调函数，应该唤醒其对应的I/O线程(一般阻塞于poll)，具体实现方法时注册一个eventfd,取名为wakefd,插了回调则在wakefd里面写一个字节就行。值得一提的是，因为wakefd单单就是起到唤醒I/O线程的作用，所以他对应的channel实际上除了刷新这个fd什么都没做，因为他要做的事情都放在回调队列里面去了。

如下的`doPendingFunctors()`位置:
```c++
void EventLoop::loop()
{
/**/
  while (!quit_)
  {
    activeChannels_.clear();
    pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_);
    for (ChannelList::iterator it = activeChannels_.begin();
        it != activeChannels_.end(); ++it)
    {
      (*it)->handleEvent();
    }
    doPendingFunctors();
  }
}
```

EventLoop::runInLoop()方法：
当前线程是I/O线程直接运行回调函数，若不是，插入EventLoop的回调队列
```c++
void EventLoop::runInLoop(const Functor& cb)
{
  if (isInLoopThread()) {
    cb();
  }
  else {
    queueInLoop(cb);
  }
}
```
EventLoop::queueInLoop()方法:
所以真正有线程安全问题的地方只有pendingFunctors_,加锁就好了
```c++
void EventLoop::queueInLoop(const Functor& cb)
{
  {
  MutexLockGuard lock(mutex_);
  pendingFunctors_.push_back(cb);
  }

  if (!isInLoopThread() || callingPendingFunctors_) {
    wakeup();
  }
}
```

并且在执行回调队列的时候采用了交换手法将执行回调函数放在了临界区外,最大限度减少race condition
```c++

void EventLoop::doPendingFunctors()
{
  std::vector<Functor> functors;
  callingPendingFunctors_ = true;
  {
  MutexLockGuard lock(mutex_);
  functors.swap(pendingFunctors_);
  }

  for (size_t i = 0; i < functors.size(); ++i) {
    functors[i]();
  }
  callingPendingFunctors_ = false;
}
```
这也是reactor模型的巧妙之处，什么叫one loop per thread?!!懂了吧。
