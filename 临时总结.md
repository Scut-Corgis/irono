用来记载自己做项目时的细节，防止遗忘，基本上本文档会最终整合到其他文档中，读者没必要看，只是自己逐步实现项目时的记录，当然如果你感兴趣一步步怎么搭建出来的可以看看，作为一个可选项吧。
# 日志系统
> made in 2021.11.27
1. `unique_ptr`对于检查错误的帮助,如`AsyncLogging.h`用它管理Buffer,不仅实现了RTTI,而且帮助我发现了没有使用move()转为右值的问题,因为`unique_ptr`发现了我使用`push_back()`时的拷贝缓冲区,编译时便报错了,让我修改了bug

2. `FileUtil.h`实现的类AppenFile做为最底层与文件打交道的类,因为只有日志后端线程唯一的拥有这样一个类的unique_ptr,所以理论上写文件不用加锁,可以用效率高的多`fwrite_unlocked()`,而且使用了`setbuffer()`为文件创立了在用户栈上缓冲区,只有每3次append才会fflush,减少了磁盘IO次数.

3. 日志前端即使用宏LOG_TRACE等输出日志信息的线程,会进入`AsyncLogging`类,使用其成员函数append,并用了`AsyncLogging`类的数据成员currentBufeer和nextBuffer_作为前端日志缓冲区,日志前端需要全程加锁,不过临界区很短,nextBuffer_和currentBuffer_的切换也采用的移动语义,一但当前的currentBuffer写满了则会切换,并在临界区结束前唤醒日志后端线程.

4. 日志后端线程全程运行在`AsyncLogging`类的`threadFunc()`中,并时刻提供了两个全新的缓冲区buffer,用来快速替换日志前端的缓冲Buffer,并且使用了临时量vector交换方法,将前后端对应临界区降至最低,基本上只有几次移动替换缓冲区的过程,最大限度的降低的前后端的竞争.

5. 日志后端的逻辑,大致为前端写满了一个Buffer就通过条件变量唤醒,或者超时唤醒.Logging线程全程存在于程序的运行期.

6. `CountDownLatch`,我称之为记数门阀,是一种线程同步手段,其中前面的线程完成了某些条件便会减少门阀计数,当计数为0则使用条件变量唤醒等在门前的后面的线程.

7. 整个日志逻辑: 生成`LogStream`类,其中有个临时Buffer,一行"<<"的都写在这个临时Buffer里面,然后这行结束,类自动析构,析沟时会往日志前端写日志,接着则是前后端日志的逻辑了.这样对外提供了非常简洁易用的接口,而隐藏了复杂的日志内部细节.
   
其他记录：
* GDB多线程调试真麻烦，虽然很清晰，但是我始终觉得效率不高，还是直接printf实在，不过gdb用来学习代码逻辑倒是非常不错。
* 有一说一，智能指针真的很好用，能帮你发现许多写代码时的小问题，除了什么RAII、copy on write、对象生命期管理等一堆手法技巧，还能帮你检查代码逻辑呢，具体原因可以看我上面的第一条。
