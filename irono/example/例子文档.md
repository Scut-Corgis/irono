* pingpong

    实现了类似echo协议的服务器和客户端，可用于测试服务器吞吐量。

* test

    简单的服务器和客户端的框架实现例子

* chat
  
    聊天室程序，`codec.h`为`string<->Buffer`的解编码器. 

    `client.cc`为客户端, `server.cc`为单线程简单服务器.

    **三种更高性能的服务器实现：**

    前两种在最外层的Server对象中维护了一个总体Tcp连接的集合，这样每次收到了一个Tcp连接发送的信息，经过解码器解码出一条完整信息后，就遍历维护着所有Tcp连接的集合并将信息发送给其所有连接成员，这属于临界区，需要加锁，理论上只要没有用户进出聊天室，那么这里就不会成为临界区，因为没有数据结构的改变，但是为了实现用户的出入功能，该维护所有Tcp连接的集合需要动态的增加减少用户数，即涉及到了写操作，则读写互斥，成为了临界区，一般来说用户进出的频率远不如聊天室中发送信息的频率，因此读事件远远多于写事件，读写锁是最好的方案。但是写操作很容易产生饥饿，给聊天室想进入的人极大的延迟，体验很差，因为聊天室人一多，它就需要等待更久才能加入聊天室，因此采用copy-on-write.

    前两种方法，维护着所有Tcp连接的集合，临界区过大。第三种只维护着I/O线程即eventloop的集合体，当收到一个聊天室消息，只需要将这个消息发送给每个eventLoop，而I/O线程数量最多不到10个，临界区非常小，然后可以绑定一个回调事件，即发送这个信息给自己eventloop中的所有Tcp连接成员。

    但这里有一个问题，我的框架eventloop是不会维护Tcp连接集合的，只有外层TcpServer会，因此采取thread local变量，每个I/O线程实现了这样一个线程独有的集合，但名字却相同以使代码可以复用逻辑更加清晰。

    `server.threaded.cc`使用多线程TcpServer,采用互斥锁保护共享数据.

    `server_threaded_efficient.cc`借用智能指针`shared_ptr`实现了`copy-on-write`，可作为读写锁的更高效的替代。

    `server_threaded_highperformance.cc`采用thread local变量，线程单例手法，实现多线程的高效转发。

* echo
  
    反射服务器

    时间轮的例子在此实现